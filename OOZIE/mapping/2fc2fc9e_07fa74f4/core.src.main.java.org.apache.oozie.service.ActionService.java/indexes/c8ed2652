

















package org.apache.oozie.service;

import org.apache.hadoop.util.ReflectionUtils;
import org.apache.oozie.action.ActionExecutor;
import org.apache.oozie.action.control.EndActionExecutor;
import org.apache.oozie.action.control.ForkActionExecutor;
import org.apache.oozie.action.control.JoinActionExecutor;
import org.apache.oozie.action.control.KillActionExecutor;
import org.apache.oozie.action.control.StartActionExecutor;
import org.apache.oozie.service.Service;
import org.apache.oozie.service.ServiceException;
import org.apache.oozie.service.Services;
import org.apache.oozie.util.ParamChecker;
import org.apache.oozie.util.XLog;
import org.apache.oozie.ErrorCode;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class ActionService implements Service {

    public static final String CONF_ACTION_EXECUTOR_CLASSES = CONF_PREFIX + "ActionService.executor.classes";

    public static final String CONF_ACTION_EXECUTOR_EXT_CLASSES = CONF_PREFIX + "ActionService.executor.ext.classes";

    private Services services;
    private Map<String, Class<? extends ActionExecutor>> executors;
    private static XLog LOG = XLog.getLog(ActionService.class);

    @SuppressWarnings("unchecked")
    public void init(Services services) throws ServiceException {
        this.services = services;
        ActionExecutor.enableInit();
        ActionExecutor.resetInitInfo();
        ActionExecutor.disableInit();
        executors = new HashMap<String, Class<? extends ActionExecutor>>();

        Class<? extends ActionExecutor>[] classes = new Class[] { StartActionExecutor.class,
            EndActionExecutor.class, KillActionExecutor.class,  ForkActionExecutor.class, JoinActionExecutor.class };
        registerExecutors(classes);

        classes = (Class<? extends ActionExecutor>[]) ConfigurationService.getClasses
                (services.getConf(), CONF_ACTION_EXECUTOR_CLASSES);
        registerExecutors(classes);

        classes = (Class<? extends ActionExecutor>[]) ConfigurationService.getClasses
                (services.getConf(), CONF_ACTION_EXECUTOR_EXT_CLASSES);
        registerExecutors(classes);
    }

    private void registerExecutors(Class<? extends ActionExecutor>[] classes) throws ServiceException {
        if (classes != null) {
            for (Class<? extends ActionExecutor> executorClass : classes) {
                register(executorClass);
            }
        }
    }

    public void destroy() {
        ActionExecutor.enableInit();
        ActionExecutor.resetInitInfo();
        ActionExecutor.disableInit();
        executors = null;
    }

    public Class<? extends Service> getInterface() {
        return ActionService.class;
    }

    public void register(Class<? extends ActionExecutor> klass) throws ServiceException {
        ActionExecutor executor = (ActionExecutor) ReflectionUtils.newInstance(klass, services.getConf());
        LOG.trace("Registering action type [{0}] class [{1}]", executor.getType(), klass);
        if (executors.containsKey(executor.getType())) {
            throw new ServiceException(ErrorCode.E0150, executor.getType());
        }
        ActionExecutor.enableInit();
        executor.initActionType();
        ActionExecutor.disableInit();
        executors.put(executor.getType(), klass);
        LOG.trace("Registered Action executor for action type [{0}] class [{1}]", executor.getType(), klass);
    }

    public ActionExecutor getExecutor(String actionType) {
        ParamChecker.notEmpty(actionType, "actionType");
        Class<? extends ActionExecutor> executorClass = executors.get(actionType);
        return (executorClass != null) ? (ActionExecutor) ReflectionUtils.newInstance(executorClass, null) : null;
    }

    Set<String> getActionTypes() {
        return executors.keySet();
    }
}
